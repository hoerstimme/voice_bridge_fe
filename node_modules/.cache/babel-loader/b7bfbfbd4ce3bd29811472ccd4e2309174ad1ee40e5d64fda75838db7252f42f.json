{"ast":null,"code":"var _jsxFileName = \"/home/mandic/PycharmProjects/voice_bridge_vtv/src/components/AudioStreamer.jsx\",\n  _s = $RefreshSig$();\nimport React, { useRef, useState, useEffect } from 'react';\nimport useVoiceStore from \"../store/useVoiceStore\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst START_SPEAKING_THRESHOLD = 0.05; // trigger when volume > this\nconst STOP_SPEAKING_THRESHOLD = 0.01; // consider silence when volume < this\nconst SILENCE_DURATION_SEC = 1;\nfunction AudioStreamer() {\n  _s();\n  const [recording, setRecording] = useState(false);\n  const [mode, setMode] = useState('interval'); // interval | silence | full | hybrid\n\n  const audioContextRef = useRef(null);\n  const sourceRef = useRef(null);\n  const processorRef = useRef(null);\n  const mediaStreamRef = useRef(null);\n  const chunksRef = useRef([]);\n  const intervalRef = useRef(null);\n  const fullRecordingRef = useRef([]);\n  const silenceBufferRef = useRef([]);\n  const silenceStartTimeRef = useRef(null);\n  const hybridChunksRef = useRef([]);\n  const hybridLastFlushRef = useRef(Date.now());\n  const audioRef = useRef(null);\n  const mediaSourceRef = useRef(null);\n  const sourceBufferRef = useRef(null);\n  const chunkQueueRef = useRef([]);\n  const isAppendingRef = useRef(false);\n  const {\n    selectedVoice\n  } = useVoiceStore.getState();\n  const handleNewChunk = arrayBuffer => {\n    chunkQueueRef.current.push(arrayBuffer);\n    if (!isAppendingRef.current) {\n      appendNextChunk();\n    }\n  };\n  const appendNextChunk = () => {\n    const sourceBuffer = sourceBufferRef.current;\n    if (!sourceBuffer || sourceBuffer.updating) return;\n    const queue = chunkQueueRef.current;\n    if (!queue.length) {\n      isAppendingRef.current = false;\n      return;\n    }\n    const nextChunk = queue.shift();\n    isAppendingRef.current = true;\n    sourceBuffer.appendBuffer(nextChunk);\n    if (audioRef.current && audioRef.current.paused) {\n      audioRef.current.play().catch(() => {});\n    }\n  };\n  useEffect(() => {\n    if (processorRef.current) processorRef.current.disconnect();\n    if (sourceRef.current) sourceRef.current.disconnect();\n    fullRecordingRef.current = [];\n    chunksRef.current = [];\n    hybridChunksRef.current = [];\n    silenceBufferRef.current = [];\n  }, [mode]);\n  useEffect(() => {\n    const audioEl = audioRef.current;\n    if (!audioEl) return;\n    const mediaSource = new MediaSource();\n    mediaSourceRef.current = mediaSource;\n    audioEl.src = URL.createObjectURL(mediaSource);\n    mediaSource.addEventListener('sourceopen', () => {\n      const sourceBuffer = mediaSource.addSourceBuffer('audio/webm; codecs=\"opus\"');\n      sourceBuffer.mode = 'sequence';\n      sourceBufferRef.current = sourceBuffer;\n      sourceBuffer.addEventListener('updateend', appendNextChunk);\n    });\n    return () => {\n      var _mediaSourceRef$curre;\n      if (((_mediaSourceRef$curre = mediaSourceRef.current) === null || _mediaSourceRef$curre === void 0 ? void 0 : _mediaSourceRef$curre.readyState) === 'open') {\n        mediaSourceRef.current.endOfStream();\n      }\n      if (audioRef.current) {\n        audioRef.current.pause();\n        audioRef.current.src = '';\n      }\n    };\n  }, []);\n  const startRecording = async () => {\n    const stream = await navigator.mediaDevices.getUserMedia({\n      audio: true\n    });\n    mediaStreamRef.current = stream;\n    const audioContext = new (window.AudioContext || window.webkitAudioContext)();\n    audioContextRef.current = audioContext;\n    const source = audioContext.createMediaStreamSource(stream);\n    const processor = audioContext.createScriptProcessor(4096, 1, 1);\n    source.connect(processor);\n    processor.connect(audioContext.destination);\n    if (mode === 'interval') {\n      intervalRef.current = setInterval(() => {\n        if (chunksRef.current.length) {\n          const wavBlob = exportWAV(chunksRef.current, audioContext.sampleRate);\n          chunksRef.current = [];\n          sendChunk(wavBlob);\n        }\n      }, 2000);\n    }\n    let isSpeaking = false;\n    let silenceStartTime = null;\n    processor.onaudioprocess = e => {\n      const input = e.inputBuffer.getChannelData(0);\n      const buffer = new Float32Array(input);\n      const now = Date.now();\n      const volume = Math.sqrt(buffer.reduce((a, b) => a + b * b, 0) / buffer.length);\n      console.log(volume);\n\n      // Detect start of speech\n      if (!isSpeaking && volume > START_SPEAKING_THRESHOLD) {\n        isSpeaking = true;\n        silenceStartTime = null;\n        if (mode === 'silence') silenceBufferRef.current = [];\n        if (mode === 'hybrid') hybridChunksRef.current = [];\n        console.log(\"üéôÔ∏è Start speaking\");\n      }\n\n      // Detect potential silence after speaking\n      if (isSpeaking && volume < STOP_SPEAKING_THRESHOLD) {\n        if (!silenceStartTime) silenceStartTime = now;\n      } else if (volume >= STOP_SPEAKING_THRESHOLD) {\n        silenceStartTime = null;\n      }\n      const silentLongEnough = silenceStartTime && now - silenceStartTime > SILENCE_DURATION_SEC * 1000;\n\n      // Silence mode\n      if (mode === 'silence') {\n        if (isSpeaking) {\n          silenceBufferRef.current.push(buffer);\n        }\n        if (silentLongEnough && isSpeaking) {\n          isSpeaking = false;\n          silenceStartTime = null;\n          if (silenceBufferRef.current.length > 0) {\n            const wav = exportWAV(silenceBufferRef.current, audioContext.sampleRate);\n            silenceBufferRef.current = [];\n            sendChunk(wav);\n          }\n          console.log(\"‚èπÔ∏è Stop speaking (silence mode)\");\n        }\n      }\n\n      // Hybrid mode\n      if (mode === 'hybrid') {\n        if (isSpeaking) {\n          hybridChunksRef.current.push(buffer);\n        }\n        const timeSinceLastFlush = now - hybridLastFlushRef.current > 2000;\n        if (timeSinceLastFlush && volume < STOP_SPEAKING_THRESHOLD) {\n          isSpeaking = false;\n          silenceStartTime = null;\n          hybridLastFlushRef.current = now;\n          if (hybridChunksRef.current.length > 0) {\n            const wav = exportWAV(hybridChunksRef.current, audioContext.sampleRate);\n            hybridChunksRef.current = [];\n            sendChunk(wav);\n          }\n          console.log(\"‚èπÔ∏è Stop speaking / flush (hybrid mode)\");\n        }\n      }\n\n      // For interval/full modes, we still store raw chunks\n      if (mode === 'interval' || mode === 'full') {\n        chunksRef.current.push(buffer);\n        fullRecordingRef.current.push(buffer);\n      }\n    };\n    setRecording(true);\n    sourceRef.current = source;\n    processorRef.current = processor;\n  };\n  const stopRecording = () => {\n    var _audioContextRef$curr;\n    if (processorRef.current) processorRef.current.disconnect();\n    if (sourceRef.current) sourceRef.current.disconnect();\n    if (((_audioContextRef$curr = audioContextRef.current) === null || _audioContextRef$curr === void 0 ? void 0 : _audioContextRef$curr.state) !== 'closed') audioContextRef.current.close();\n    if (mediaStreamRef.current) mediaStreamRef.current.getTracks().forEach(t => t.stop());\n    if (intervalRef.current) {\n      clearInterval(intervalRef.current);\n      intervalRef.current = null;\n    }\n    setRecording(false);\n    if (mode === 'full') {\n      const fullBlob = exportWAV(fullRecordingRef.current, audioContextRef.current.sampleRate);\n      sendChunk(fullBlob);\n    }\n  };\n  const sendChunk = async blob => {\n    const formData = new FormData();\n    formData.append('audio_file', blob, 'chunk.wav');\n    formData.append('voice_name', selectedVoice);\n    try {\n      const response = await fetch('http://127.0.0.1:8001/convert_voice_stream_bytes_webm', {\n        method: 'POST',\n        body: formData\n      });\n      if (!response.ok) throw new Error('Failed to convert audio');\n      const arrayBuffer = await response.arrayBuffer();\n      handleNewChunk(arrayBuffer);\n    } catch (err) {\n      console.error('Error sending chunk:', err);\n    }\n  };\n  const exportWAV = (buffers, sampleRate) => {\n    const length = buffers.reduce((sum, b) => sum + b.length, 0);\n    const mergedBuffer = new Float32Array(length);\n    let offset = 0;\n    for (const b of buffers) {\n      mergedBuffer.set(b, offset);\n      offset += b.length;\n    }\n    const buffer = new ArrayBuffer(44 + mergedBuffer.length * 2);\n    const view = new DataView(buffer);\n    const writeString = (v, o, s) => [...s].forEach((ch, i) => v.setUint8(o + i, ch.charCodeAt(0)));\n    writeString(view, 0, 'RIFF');\n    view.setUint32(4, 36 + mergedBuffer.length * 2, true);\n    writeString(view, 8, 'WAVE');\n    writeString(view, 12, 'fmt ');\n    view.setUint32(16, 16, true);\n    view.setUint16(20, 1, true);\n    view.setUint16(22, 1, true);\n    view.setUint32(24, sampleRate, true);\n    view.setUint32(28, sampleRate * 2, true);\n    view.setUint16(32, 2, true);\n    view.setUint16(34, 16, true);\n    writeString(view, 36, 'data');\n    view.setUint32(40, mergedBuffer.length * 2, true);\n    for (let i = 0, idx = 44; i < mergedBuffer.length; i++, idx += 2) {\n      const s = Math.max(-1, Math.min(1, mergedBuffer[i]));\n      view.setInt16(idx, s < 0 ? s * 0x8000 : s * 0x7FFF, true);\n    }\n    return new Blob([view], {\n      type: 'audio/wav'\n    });\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"p-4 max-w-xl mx-auto flex flex-col gap-4\",\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"flex gap-2\",\n      children: [/*#__PURE__*/_jsxDEV(\"select\", {\n        className: \"border px-2 py-1\",\n        value: mode,\n        onChange: e => setMode(e.target.value),\n        disabled: recording,\n        children: [/*#__PURE__*/_jsxDEV(\"option\", {\n          value: \"interval\",\n          children: \"Interval\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 271,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"option\", {\n          value: \"silence\",\n          children: \"Silence-Based\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 272,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"option\", {\n          value: \"hybrid\",\n          children: \"Hybrid\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 273,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"option\", {\n          value: \"full\",\n          children: \"Full Recording\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 274,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 265,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        className: `px-4 py-2 text-white rounded ${recording ? 'bg-red-600' : 'bg-green-600'}`,\n        onClick: recording ? stopRecording : startRecording,\n        children: recording ? 'üõë Stop' : 'üéôÔ∏è Start'\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 276,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 264,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"audio\", {\n      ref: audioRef,\n      controls: true,\n      autoPlay: true\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 283,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 263,\n    columnNumber: 5\n  }, this);\n}\n_s(AudioStreamer, \"3udM7Gko9bn+I+g3xJXgBSe1Fxw=\");\n_c = AudioStreamer;\nexport default AudioStreamer;\nvar _c;\n$RefreshReg$(_c, \"AudioStreamer\");","map":{"version":3,"names":["React","useRef","useState","useEffect","useVoiceStore","jsxDEV","_jsxDEV","START_SPEAKING_THRESHOLD","STOP_SPEAKING_THRESHOLD","SILENCE_DURATION_SEC","AudioStreamer","_s","recording","setRecording","mode","setMode","audioContextRef","sourceRef","processorRef","mediaStreamRef","chunksRef","intervalRef","fullRecordingRef","silenceBufferRef","silenceStartTimeRef","hybridChunksRef","hybridLastFlushRef","Date","now","audioRef","mediaSourceRef","sourceBufferRef","chunkQueueRef","isAppendingRef","selectedVoice","getState","handleNewChunk","arrayBuffer","current","push","appendNextChunk","sourceBuffer","updating","queue","length","nextChunk","shift","appendBuffer","paused","play","catch","disconnect","audioEl","mediaSource","MediaSource","src","URL","createObjectURL","addEventListener","addSourceBuffer","_mediaSourceRef$curre","readyState","endOfStream","pause","startRecording","stream","navigator","mediaDevices","getUserMedia","audio","audioContext","window","AudioContext","webkitAudioContext","source","createMediaStreamSource","processor","createScriptProcessor","connect","destination","setInterval","wavBlob","exportWAV","sampleRate","sendChunk","isSpeaking","silenceStartTime","onaudioprocess","e","input","inputBuffer","getChannelData","buffer","Float32Array","volume","Math","sqrt","reduce","a","b","console","log","silentLongEnough","wav","timeSinceLastFlush","stopRecording","_audioContextRef$curr","state","close","getTracks","forEach","t","stop","clearInterval","fullBlob","blob","formData","FormData","append","response","fetch","method","body","ok","Error","err","error","buffers","sum","mergedBuffer","offset","set","ArrayBuffer","view","DataView","writeString","v","o","s","ch","i","setUint8","charCodeAt","setUint32","setUint16","idx","max","min","setInt16","Blob","type","className","children","value","onChange","target","disabled","fileName","_jsxFileName","lineNumber","columnNumber","onClick","ref","controls","autoPlay","_c","$RefreshReg$"],"sources":["/home/mandic/PycharmProjects/voice_bridge_vtv/src/components/AudioStreamer.jsx"],"sourcesContent":["import React, { useRef, useState, useEffect } from 'react';\nimport useVoiceStore from \"../store/useVoiceStore\";\n\n\nconst START_SPEAKING_THRESHOLD = 0.05; // trigger when volume > this\nconst STOP_SPEAKING_THRESHOLD = 0.01;  // consider silence when volume < this\nconst SILENCE_DURATION_SEC = 1;\n\nfunction AudioStreamer() {\n  const [recording, setRecording] = useState(false);\n  const [mode, setMode] = useState('interval'); // interval | silence | full | hybrid\n\n  const audioContextRef = useRef(null);\n  const sourceRef = useRef(null);\n  const processorRef = useRef(null);\n  const mediaStreamRef = useRef(null);\n  const chunksRef = useRef([]);\n  const intervalRef = useRef(null);\n  const fullRecordingRef = useRef([]);\n  const silenceBufferRef = useRef([]);\n  const silenceStartTimeRef = useRef(null);\n  const hybridChunksRef = useRef([]);\n  const hybridLastFlushRef = useRef(Date.now());\n\n  const audioRef = useRef(null);\n  const mediaSourceRef = useRef(null);\n  const sourceBufferRef = useRef(null);\n  const chunkQueueRef = useRef([]);\n  const isAppendingRef = useRef(false);\n\n  const { selectedVoice } = useVoiceStore.getState();\n\n  const handleNewChunk = (arrayBuffer) => {\n    chunkQueueRef.current.push(arrayBuffer);\n    if (!isAppendingRef.current) {\n      appendNextChunk();\n    }\n  };\n\n  const appendNextChunk = () => {\n    const sourceBuffer = sourceBufferRef.current;\n    if (!sourceBuffer || sourceBuffer.updating) return;\n    const queue = chunkQueueRef.current;\n    if (!queue.length) {\n      isAppendingRef.current = false;\n      return;\n    }\n    const nextChunk = queue.shift();\n    isAppendingRef.current = true;\n    sourceBuffer.appendBuffer(nextChunk);\n    if (audioRef.current && audioRef.current.paused) {\n      audioRef.current.play().catch(() => {});\n    }\n  };\n\n\n  useEffect(() => {\n      if (processorRef.current) processorRef.current.disconnect();\n      if (sourceRef.current) sourceRef.current.disconnect();\n\n      fullRecordingRef.current = [];\n      chunksRef.current = [];\n      hybridChunksRef.current = [];\n      silenceBufferRef.current = [];\n  }, [mode]);\n\n  useEffect(() => {\n    const audioEl = audioRef.current;\n    if (!audioEl) return;\n    const mediaSource = new MediaSource();\n    mediaSourceRef.current = mediaSource;\n    audioEl.src = URL.createObjectURL(mediaSource);\n    mediaSource.addEventListener('sourceopen', () => {\n      const sourceBuffer = mediaSource.addSourceBuffer('audio/webm; codecs=\"opus\"');\n      sourceBuffer.mode = 'sequence';\n      sourceBufferRef.current = sourceBuffer;\n      sourceBuffer.addEventListener('updateend', appendNextChunk);\n    });\n    return () => {\n      if (mediaSourceRef.current?.readyState === 'open') {\n        mediaSourceRef.current.endOfStream();\n      }\n      if (audioRef.current) {\n        audioRef.current.pause();\n        audioRef.current.src = '';\n      }\n    };\n  }, []);\n\n  const startRecording = async () => {\n    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n    mediaStreamRef.current = stream;\n    const audioContext = new (window.AudioContext || window.webkitAudioContext)();\n    audioContextRef.current = audioContext;\n\n    const source = audioContext.createMediaStreamSource(stream);\n    const processor = audioContext.createScriptProcessor(4096, 1, 1);\n    source.connect(processor);\n    processor.connect(audioContext.destination);\n\n    if (mode === 'interval') {\n      intervalRef.current = setInterval(() => {\n        if (chunksRef.current.length) {\n          const wavBlob = exportWAV(chunksRef.current, audioContext.sampleRate);\n          chunksRef.current = [];\n          sendChunk(wavBlob);\n        }\n      }, 2000);\n    }\n\n    let isSpeaking = false;\n    let silenceStartTime = null;\n\n    processor.onaudioprocess = (e) => {\n      const input = e.inputBuffer.getChannelData(0);\n      const buffer = new Float32Array(input);\n\n      const now = Date.now();\n      const volume = Math.sqrt(buffer.reduce((a, b) => a + b * b, 0) / buffer.length);\n      console.log(volume);\n\n      // Detect start of speech\n      if (!isSpeaking && volume > START_SPEAKING_THRESHOLD) {\n        isSpeaking = true;\n        silenceStartTime = null;\n\n        if (mode === 'silence') silenceBufferRef.current = [];\n        if (mode === 'hybrid') hybridChunksRef.current = [];\n\n        console.log(\"üéôÔ∏è Start speaking\");\n      }\n\n      // Detect potential silence after speaking\n      if (isSpeaking && volume < STOP_SPEAKING_THRESHOLD) {\n        if (!silenceStartTime) silenceStartTime = now;\n      } else if (volume >= STOP_SPEAKING_THRESHOLD) {\n        silenceStartTime = null;\n      }\n\n      const silentLongEnough = silenceStartTime && (now - silenceStartTime > SILENCE_DURATION_SEC * 1000);\n\n      // Silence mode\n      if (mode === 'silence') {\n        if (isSpeaking) {\n          silenceBufferRef.current.push(buffer);\n        }\n\n        if (silentLongEnough && isSpeaking) {\n          isSpeaking = false;\n          silenceStartTime = null;\n\n          if (silenceBufferRef.current.length > 0) {\n            const wav = exportWAV(silenceBufferRef.current, audioContext.sampleRate);\n            silenceBufferRef.current = [];\n            sendChunk(wav);\n          }\n          console.log(\"‚èπÔ∏è Stop speaking (silence mode)\");\n        }\n      }\n\n      // Hybrid mode\n      if (mode === 'hybrid') {\n        if (isSpeaking) {\n          hybridChunksRef.current.push(buffer);\n        }\n\n        const timeSinceLastFlush = now - hybridLastFlushRef.current > 2000;\n\n        if (timeSinceLastFlush && volume < STOP_SPEAKING_THRESHOLD) {\n          isSpeaking = false;\n          silenceStartTime = null;\n          hybridLastFlushRef.current = now;\n\n          if (hybridChunksRef.current.length > 0) {\n            const wav = exportWAV(hybridChunksRef.current, audioContext.sampleRate);\n            hybridChunksRef.current = [];\n            sendChunk(wav);\n          }\n          console.log(\"‚èπÔ∏è Stop speaking / flush (hybrid mode)\");\n        }\n      }\n\n      // For interval/full modes, we still store raw chunks\n      if (mode === 'interval' || mode === 'full') {\n        chunksRef.current.push(buffer);\n        fullRecordingRef.current.push(buffer);\n      }\n    };\n\n    setRecording(true);\n    sourceRef.current = source;\n    processorRef.current = processor;\n  };\n\n\n  const stopRecording = () => {\n    if (processorRef.current) processorRef.current.disconnect();\n    if (sourceRef.current) sourceRef.current.disconnect();\n    if (audioContextRef.current?.state !== 'closed') audioContextRef.current.close();\n    if (mediaStreamRef.current) mediaStreamRef.current.getTracks().forEach((t) => t.stop());\n    if (intervalRef.current) {\n      clearInterval(intervalRef.current);\n      intervalRef.current = null;\n    }\n\n    setRecording(false);\n\n    if (mode === 'full') {\n      const fullBlob = exportWAV(fullRecordingRef.current, audioContextRef.current.sampleRate);\n      sendChunk(fullBlob);\n    }\n  };\n\n  const sendChunk = async (blob) => {\n    const formData = new FormData();\n    formData.append('audio_file', blob, 'chunk.wav');\n    formData.append('voice_name', selectedVoice);\n    try {\n      const response = await fetch('http://127.0.0.1:8001/convert_voice_stream_bytes_webm', {\n        method: 'POST',\n        body: formData,\n      });\n      if (!response.ok) throw new Error('Failed to convert audio');\n      const arrayBuffer = await response.arrayBuffer();\n      handleNewChunk(arrayBuffer);\n    } catch (err) {\n      console.error('Error sending chunk:', err);\n    }\n  };\n\n  const exportWAV = (buffers, sampleRate) => {\n    const length = buffers.reduce((sum, b) => sum + b.length, 0);\n    const mergedBuffer = new Float32Array(length);\n    let offset = 0;\n    for (const b of buffers) {\n      mergedBuffer.set(b, offset);\n      offset += b.length;\n    }\n    const buffer = new ArrayBuffer(44 + mergedBuffer.length * 2);\n    const view = new DataView(buffer);\n    const writeString = (v, o, s) => [...s].forEach((ch, i) => v.setUint8(o + i, ch.charCodeAt(0)));\n    writeString(view, 0, 'RIFF');\n    view.setUint32(4, 36 + mergedBuffer.length * 2, true);\n    writeString(view, 8, 'WAVE');\n    writeString(view, 12, 'fmt ');\n    view.setUint32(16, 16, true);\n    view.setUint16(20, 1, true);\n    view.setUint16(22, 1, true);\n    view.setUint32(24, sampleRate, true);\n    view.setUint32(28, sampleRate * 2, true);\n    view.setUint16(32, 2, true);\n    view.setUint16(34, 16, true);\n    writeString(view, 36, 'data');\n    view.setUint32(40, mergedBuffer.length * 2, true);\n    for (let i = 0, idx = 44; i < mergedBuffer.length; i++, idx += 2) {\n      const s = Math.max(-1, Math.min(1, mergedBuffer[i]));\n      view.setInt16(idx, s < 0 ? s * 0x8000 : s * 0x7FFF, true);\n    }\n    return new Blob([view], { type: 'audio/wav' });\n  };\n\n  return (\n    <div className=\"p-4 max-w-xl mx-auto flex flex-col gap-4\">\n      <div className=\"flex gap-2\">\n        <select\n          className=\"border px-2 py-1\"\n          value={mode}\n          onChange={(e) => setMode(e.target.value)}\n          disabled={recording}\n        >\n          <option value=\"interval\">Interval</option>\n          <option value=\"silence\">Silence-Based</option>\n          <option value=\"hybrid\">Hybrid</option>\n          <option value=\"full\">Full Recording</option>\n        </select>\n        <button\n          className={`px-4 py-2 text-white rounded ${recording ? 'bg-red-600' : 'bg-green-600'}`}\n          onClick={recording ? stopRecording : startRecording}\n        >\n          {recording ? 'üõë Stop' : 'üéôÔ∏è Start'}\n        </button>\n      </div>\n      <audio ref={audioRef} controls autoPlay />\n    </div>\n  );\n}\n\nexport default AudioStreamer;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}