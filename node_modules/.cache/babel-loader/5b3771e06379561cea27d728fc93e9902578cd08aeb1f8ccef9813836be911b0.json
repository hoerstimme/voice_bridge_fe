{"ast":null,"code":"var _jsxFileName = \"/home/mandic/PycharmProjects/voice_bridge_vtv/src/components/AudioStreamer.jsx\",\n  _s = $RefreshSig$();\nimport React, { useRef, useState, useEffect } from 'react';\nimport useVoiceStore from \"../store/useVoiceStore\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst START_SPEAKING_THRESHOLD = 0.05; // trigger when volume > this\nconst STOP_SPEAKING_THRESHOLD = 0.01; // consider silence when volume < this\nconst SILENCE_DURATION_SEC = 1;\nfunction AudioStreamer() {\n  _s();\n  const [recording, setRecording] = useState(false);\n  const [mode, setMode] = useState('interval'); // interval | silence | full | hybrid\n\n  const audioContextRef = useRef(null);\n  const sourceRef = useRef(null);\n  const processorRef = useRef(null);\n  const mediaStreamRef = useRef(null);\n  const chunksRef = useRef([]);\n  const intervalRef = useRef(null);\n  const fullRecordingRef = useRef([]);\n  const silenceBufferRef = useRef([]);\n  const hybridChunksRef = useRef([]);\n  const hybridLastFlushRef = useRef(Date.now());\n  const audioRef = useRef(null);\n  const mediaSourceRef = useRef(null);\n  const sourceBufferRef = useRef(null);\n  const chunkQueueRef = useRef([]);\n  const isAppendingRef = useRef(false);\n  const handleNewChunk = arrayBuffer => {\n    chunkQueueRef.current.push(arrayBuffer);\n    if (!isAppendingRef.current) {\n      appendNextChunk();\n    }\n  };\n  const appendNextChunk = () => {\n    const sourceBuffer = sourceBufferRef.current;\n    if (!sourceBuffer || sourceBuffer.updating) return;\n    const queue = chunkQueueRef.current;\n    if (!queue.length) {\n      isAppendingRef.current = false;\n      return;\n    }\n    const nextChunk = queue.shift();\n    isAppendingRef.current = true;\n    sourceBuffer.appendBuffer(nextChunk);\n    if (audioRef.current && audioRef.current.paused) {\n      audioRef.current.play().catch(() => {});\n    }\n  };\n  useEffect(() => {\n    if (processorRef.current) processorRef.current.disconnect();\n    if (sourceRef.current) sourceRef.current.disconnect();\n    fullRecordingRef.current = [];\n    chunksRef.current = [];\n    hybridChunksRef.current = [];\n    silenceBufferRef.current = [];\n  }, [mode]);\n  useEffect(() => {\n    const audioEl = audioRef.current;\n    if (!audioEl) return;\n    const mediaSource = new MediaSource();\n    mediaSourceRef.current = mediaSource;\n    audioEl.src = URL.createObjectURL(mediaSource);\n    mediaSource.addEventListener('sourceopen', () => {\n      const sourceBuffer = mediaSource.addSourceBuffer('audio/webm; codecs=\"opus\"');\n      sourceBuffer.mode = 'sequence';\n      sourceBufferRef.current = sourceBuffer;\n      sourceBuffer.addEventListener('updateend', appendNextChunk);\n    });\n    return () => {\n      var _mediaSourceRef$curre;\n      if (((_mediaSourceRef$curre = mediaSourceRef.current) === null || _mediaSourceRef$curre === void 0 ? void 0 : _mediaSourceRef$curre.readyState) === 'open') {\n        mediaSourceRef.current.endOfStream();\n      }\n      if (audioRef.current) {\n        audioRef.current.pause();\n        audioRef.current.src = '';\n      }\n    };\n  }, []);\n  const startRecording = async () => {\n    const stream = await navigator.mediaDevices.getUserMedia({\n      audio: true\n    });\n    mediaStreamRef.current = stream;\n    const audioContext = new (window.AudioContext || window.webkitAudioContext)();\n    audioContextRef.current = audioContext;\n    const source = audioContext.createMediaStreamSource(stream);\n    const processor = audioContext.createScriptProcessor(4096, 1, 1);\n    source.connect(processor);\n    processor.connect(audioContext.destination);\n    if (mode === 'interval') {\n      intervalRef.current = setInterval(() => {\n        if (chunksRef.current.length) {\n          const wavBlob = exportWAV(chunksRef.current, audioContext.sampleRate);\n          chunksRef.current = [];\n          sendChunk(wavBlob);\n        }\n      }, 2000);\n    }\n    let isSpeaking = false;\n    let silenceStartTime = null;\n    processor.onaudioprocess = e => {\n      const input = e.inputBuffer.getChannelData(0);\n      const buffer = new Float32Array(input);\n      const now = Date.now();\n      const volume = Math.sqrt(buffer.reduce((a, b) => a + b * b, 0) / buffer.length);\n      console.log(volume);\n\n      // Detect start of speech\n      if (!isSpeaking && volume > START_SPEAKING_THRESHOLD) {\n        isSpeaking = true;\n        silenceStartTime = null;\n        if (mode === 'silence') silenceBufferRef.current = [];\n        if (mode === 'hybrid') hybridChunksRef.current = [];\n        console.log(\"üéôÔ∏è Start speaking\");\n      }\n\n      // Detect potential silence after speaking\n      if (isSpeaking && volume < STOP_SPEAKING_THRESHOLD) {\n        if (!silenceStartTime) silenceStartTime = now;\n      } else if (volume >= STOP_SPEAKING_THRESHOLD) {\n        silenceStartTime = null;\n      }\n      const silentLongEnough = silenceStartTime && now - silenceStartTime > SILENCE_DURATION_SEC * 1000;\n\n      // Silence mode\n      if (mode === 'silence') {\n        if (isSpeaking) {\n          silenceBufferRef.current.push(buffer);\n        }\n        if (silentLongEnough && isSpeaking) {\n          isSpeaking = false;\n          silenceStartTime = null;\n          if (silenceBufferRef.current.length > 0) {\n            const wav = exportWAV(silenceBufferRef.current, audioContext.sampleRate);\n            silenceBufferRef.current = [];\n            sendChunk(wav);\n          }\n          console.log(\"‚èπÔ∏è Stop speaking (silence mode)\");\n        }\n      }\n\n      // Hybrid mode\n      if (mode === 'hybrid') {\n        if (isSpeaking) {\n          hybridChunksRef.current.push(buffer);\n        }\n        const timeSinceLastFlush = now - hybridLastFlushRef.current > 2000;\n        if (timeSinceLastFlush && volume < STOP_SPEAKING_THRESHOLD) {\n          isSpeaking = false;\n          silenceStartTime = null;\n          hybridLastFlushRef.current = now;\n          if (hybridChunksRef.current.length > 0) {\n            const wav = exportWAV(hybridChunksRef.current, audioContext.sampleRate);\n            hybridChunksRef.current = [];\n            sendChunk(wav);\n          }\n          console.log(\"‚èπÔ∏è Stop speaking / flush (hybrid mode)\");\n        }\n      }\n\n      // For interval/full modes, we still store raw chunks\n      if (mode === 'interval' || mode === 'full') {\n        chunksRef.current.push(buffer);\n        fullRecordingRef.current.push(buffer);\n      }\n    };\n    setRecording(true);\n    sourceRef.current = source;\n    processorRef.current = processor;\n  };\n  const stopRecording = () => {\n    var _audioContextRef$curr;\n    if (processorRef.current) processorRef.current.disconnect();\n    if (sourceRef.current) sourceRef.current.disconnect();\n    if (((_audioContextRef$curr = audioContextRef.current) === null || _audioContextRef$curr === void 0 ? void 0 : _audioContextRef$curr.state) !== 'closed') audioContextRef.current.close();\n    if (mediaStreamRef.current) mediaStreamRef.current.getTracks().forEach(t => t.stop());\n    if (intervalRef.current) {\n      clearInterval(intervalRef.current);\n      intervalRef.current = null;\n    }\n    setRecording(false);\n    if (mode === 'full') {\n      const fullBlob = exportWAV(fullRecordingRef.current, audioContextRef.current.sampleRate);\n      sendChunk(fullBlob);\n    }\n  };\n  const sendChunk = async blob => {\n    const formData = new FormData();\n    formData.append('audio_file', blob, 'chunk.wav');\n    formData.append('voice_name', useVoiceStore.getState());\n    try {\n      const response = await fetch('http://127.0.0.1:8001/convert_voice_stream_bytes_webm', {\n        method: 'POST',\n        body: formData\n      });\n      if (!response.ok) throw new Error('Failed to convert audio');\n      const arrayBuffer = await response.arrayBuffer();\n      handleNewChunk(arrayBuffer);\n    } catch (err) {\n      console.error('Error sending chunk:', err);\n    }\n  };\n  const exportWAV = (buffers, sampleRate) => {\n    const length = buffers.reduce((sum, b) => sum + b.length, 0);\n    const mergedBuffer = new Float32Array(length);\n    let offset = 0;\n    for (const b of buffers) {\n      mergedBuffer.set(b, offset);\n      offset += b.length;\n    }\n    const buffer = new ArrayBuffer(44 + mergedBuffer.length * 2);\n    const view = new DataView(buffer);\n    const writeString = (v, o, s) => [...s].forEach((ch, i) => v.setUint8(o + i, ch.charCodeAt(0)));\n    writeString(view, 0, 'RIFF');\n    view.setUint32(4, 36 + mergedBuffer.length * 2, true);\n    writeString(view, 8, 'WAVE');\n    writeString(view, 12, 'fmt ');\n    view.setUint32(16, 16, true);\n    view.setUint16(20, 1, true);\n    view.setUint16(22, 1, true);\n    view.setUint32(24, sampleRate, true);\n    view.setUint32(28, sampleRate * 2, true);\n    view.setUint16(32, 2, true);\n    view.setUint16(34, 16, true);\n    writeString(view, 36, 'data');\n    view.setUint32(40, mergedBuffer.length * 2, true);\n    for (let i = 0, idx = 44; i < mergedBuffer.length; i++, idx += 2) {\n      const s = Math.max(-1, Math.min(1, mergedBuffer[i]));\n      view.setInt16(idx, s < 0 ? s * 0x8000 : s * 0x7FFF, true);\n    }\n    return new Blob([view], {\n      type: 'audio/wav'\n    });\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"p-4 max-w-xl mx-auto flex flex-col gap-4\",\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"flex gap-2\",\n      children: [/*#__PURE__*/_jsxDEV(\"select\", {\n        className: \"border px-2 py-1\",\n        value: mode,\n        onChange: e => setMode(e.target.value),\n        disabled: recording,\n        children: [/*#__PURE__*/_jsxDEV(\"option\", {\n          value: \"interval\",\n          children: \"Interval\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 269,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"option\", {\n          value: \"silence\",\n          children: \"Silence-Based\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 270,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"option\", {\n          value: \"hybrid\",\n          children: \"Hybrid\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 271,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"option\", {\n          value: \"full\",\n          children: \"Full Recording\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 272,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 263,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        className: `px-4 py-2 text-white rounded ${recording ? 'bg-red-600' : 'bg-green-600'}`,\n        onClick: recording ? stopRecording : startRecording,\n        children: recording ? 'üõë Stop' : 'üéôÔ∏è Start'\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 274,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 262,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"audio\", {\n      ref: audioRef,\n      controls: true,\n      autoPlay: true\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 281,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 261,\n    columnNumber: 5\n  }, this);\n}\n_s(AudioStreamer, \"XYg3F+JPYKcfH0YWzeThRU4p0nc=\");\n_c = AudioStreamer;\nexport default AudioStreamer;\nvar _c;\n$RefreshReg$(_c, \"AudioStreamer\");","map":{"version":3,"names":["React","useRef","useState","useEffect","useVoiceStore","jsxDEV","_jsxDEV","START_SPEAKING_THRESHOLD","STOP_SPEAKING_THRESHOLD","SILENCE_DURATION_SEC","AudioStreamer","_s","recording","setRecording","mode","setMode","audioContextRef","sourceRef","processorRef","mediaStreamRef","chunksRef","intervalRef","fullRecordingRef","silenceBufferRef","hybridChunksRef","hybridLastFlushRef","Date","now","audioRef","mediaSourceRef","sourceBufferRef","chunkQueueRef","isAppendingRef","handleNewChunk","arrayBuffer","current","push","appendNextChunk","sourceBuffer","updating","queue","length","nextChunk","shift","appendBuffer","paused","play","catch","disconnect","audioEl","mediaSource","MediaSource","src","URL","createObjectURL","addEventListener","addSourceBuffer","_mediaSourceRef$curre","readyState","endOfStream","pause","startRecording","stream","navigator","mediaDevices","getUserMedia","audio","audioContext","window","AudioContext","webkitAudioContext","source","createMediaStreamSource","processor","createScriptProcessor","connect","destination","setInterval","wavBlob","exportWAV","sampleRate","sendChunk","isSpeaking","silenceStartTime","onaudioprocess","e","input","inputBuffer","getChannelData","buffer","Float32Array","volume","Math","sqrt","reduce","a","b","console","log","silentLongEnough","wav","timeSinceLastFlush","stopRecording","_audioContextRef$curr","state","close","getTracks","forEach","t","stop","clearInterval","fullBlob","blob","formData","FormData","append","getState","response","fetch","method","body","ok","Error","err","error","buffers","sum","mergedBuffer","offset","set","ArrayBuffer","view","DataView","writeString","v","o","s","ch","i","setUint8","charCodeAt","setUint32","setUint16","idx","max","min","setInt16","Blob","type","className","children","value","onChange","target","disabled","fileName","_jsxFileName","lineNumber","columnNumber","onClick","ref","controls","autoPlay","_c","$RefreshReg$"],"sources":["/home/mandic/PycharmProjects/voice_bridge_vtv/src/components/AudioStreamer.jsx"],"sourcesContent":["import React, { useRef, useState, useEffect } from 'react';\nimport useVoiceStore from \"../store/useVoiceStore\";\n\n\nconst START_SPEAKING_THRESHOLD = 0.05; // trigger when volume > this\nconst STOP_SPEAKING_THRESHOLD = 0.01;  // consider silence when volume < this\nconst SILENCE_DURATION_SEC = 1;\n\nfunction AudioStreamer() {\n  const [recording, setRecording] = useState(false);\n  const [mode, setMode] = useState('interval'); // interval | silence | full | hybrid\n\n  const audioContextRef = useRef(null);\n  const sourceRef = useRef(null);\n  const processorRef = useRef(null);\n  const mediaStreamRef = useRef(null);\n  const chunksRef = useRef([]);\n  const intervalRef = useRef(null);\n  const fullRecordingRef = useRef([]);\n  const silenceBufferRef = useRef([]);\n  const hybridChunksRef = useRef([]);\n  const hybridLastFlushRef = useRef(Date.now());\n\n  const audioRef = useRef(null);\n  const mediaSourceRef = useRef(null);\n  const sourceBufferRef = useRef(null);\n  const chunkQueueRef = useRef([]);\n  const isAppendingRef = useRef(false);\n\n\n  const handleNewChunk = (arrayBuffer) => {\n    chunkQueueRef.current.push(arrayBuffer);\n    if (!isAppendingRef.current) {\n      appendNextChunk();\n    }\n  };\n\n  const appendNextChunk = () => {\n    const sourceBuffer = sourceBufferRef.current;\n    if (!sourceBuffer || sourceBuffer.updating) return;\n    const queue = chunkQueueRef.current;\n    if (!queue.length) {\n      isAppendingRef.current = false;\n      return;\n    }\n    const nextChunk = queue.shift();\n    isAppendingRef.current = true;\n    sourceBuffer.appendBuffer(nextChunk);\n    if (audioRef.current && audioRef.current.paused) {\n      audioRef.current.play().catch(() => {});\n    }\n  };\n\n\n  useEffect(() => {\n      if (processorRef.current) processorRef.current.disconnect();\n      if (sourceRef.current) sourceRef.current.disconnect();\n\n      fullRecordingRef.current = [];\n      chunksRef.current = [];\n      hybridChunksRef.current = [];\n      silenceBufferRef.current = [];\n  }, [mode]);\n\n  useEffect(() => {\n    const audioEl = audioRef.current;\n    if (!audioEl) return;\n    const mediaSource = new MediaSource();\n    mediaSourceRef.current = mediaSource;\n    audioEl.src = URL.createObjectURL(mediaSource);\n    mediaSource.addEventListener('sourceopen', () => {\n      const sourceBuffer = mediaSource.addSourceBuffer('audio/webm; codecs=\"opus\"');\n      sourceBuffer.mode = 'sequence';\n      sourceBufferRef.current = sourceBuffer;\n      sourceBuffer.addEventListener('updateend', appendNextChunk);\n    });\n    return () => {\n      if (mediaSourceRef.current?.readyState === 'open') {\n        mediaSourceRef.current.endOfStream();\n      }\n      if (audioRef.current) {\n        audioRef.current.pause();\n        audioRef.current.src = '';\n      }\n    };\n  }, []);\n\n  const startRecording = async () => {\n    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n    mediaStreamRef.current = stream;\n    const audioContext = new (window.AudioContext || window.webkitAudioContext)();\n    audioContextRef.current = audioContext;\n\n    const source = audioContext.createMediaStreamSource(stream);\n    const processor = audioContext.createScriptProcessor(4096, 1, 1);\n    source.connect(processor);\n    processor.connect(audioContext.destination);\n\n    if (mode === 'interval') {\n      intervalRef.current = setInterval(() => {\n        if (chunksRef.current.length) {\n          const wavBlob = exportWAV(chunksRef.current, audioContext.sampleRate);\n          chunksRef.current = [];\n          sendChunk(wavBlob);\n        }\n      }, 2000);\n    }\n\n    let isSpeaking = false;\n    let silenceStartTime = null;\n\n    processor.onaudioprocess = (e) => {\n      const input = e.inputBuffer.getChannelData(0);\n      const buffer = new Float32Array(input);\n\n      const now = Date.now();\n      const volume = Math.sqrt(buffer.reduce((a, b) => a + b * b, 0) / buffer.length);\n      console.log(volume);\n\n      // Detect start of speech\n      if (!isSpeaking && volume > START_SPEAKING_THRESHOLD) {\n        isSpeaking = true;\n        silenceStartTime = null;\n\n        if (mode === 'silence') silenceBufferRef.current = [];\n        if (mode === 'hybrid') hybridChunksRef.current = [];\n\n        console.log(\"üéôÔ∏è Start speaking\");\n      }\n\n      // Detect potential silence after speaking\n      if (isSpeaking && volume < STOP_SPEAKING_THRESHOLD) {\n        if (!silenceStartTime) silenceStartTime = now;\n      } else if (volume >= STOP_SPEAKING_THRESHOLD) {\n        silenceStartTime = null;\n      }\n\n      const silentLongEnough = silenceStartTime && (now - silenceStartTime > SILENCE_DURATION_SEC * 1000);\n\n      // Silence mode\n      if (mode === 'silence') {\n        if (isSpeaking) {\n          silenceBufferRef.current.push(buffer);\n        }\n\n        if (silentLongEnough && isSpeaking) {\n          isSpeaking = false;\n          silenceStartTime = null;\n\n          if (silenceBufferRef.current.length > 0) {\n            const wav = exportWAV(silenceBufferRef.current, audioContext.sampleRate);\n            silenceBufferRef.current = [];\n            sendChunk(wav);\n          }\n          console.log(\"‚èπÔ∏è Stop speaking (silence mode)\");\n        }\n      }\n\n      // Hybrid mode\n      if (mode === 'hybrid') {\n        if (isSpeaking) {\n          hybridChunksRef.current.push(buffer);\n        }\n\n        const timeSinceLastFlush = now - hybridLastFlushRef.current > 2000;\n\n        if (timeSinceLastFlush && volume < STOP_SPEAKING_THRESHOLD) {\n          isSpeaking = false;\n          silenceStartTime = null;\n          hybridLastFlushRef.current = now;\n\n          if (hybridChunksRef.current.length > 0) {\n            const wav = exportWAV(hybridChunksRef.current, audioContext.sampleRate);\n            hybridChunksRef.current = [];\n            sendChunk(wav);\n          }\n          console.log(\"‚èπÔ∏è Stop speaking / flush (hybrid mode)\");\n        }\n      }\n\n      // For interval/full modes, we still store raw chunks\n      if (mode === 'interval' || mode === 'full') {\n        chunksRef.current.push(buffer);\n        fullRecordingRef.current.push(buffer);\n      }\n    };\n\n    setRecording(true);\n    sourceRef.current = source;\n    processorRef.current = processor;\n  };\n\n\n  const stopRecording = () => {\n    if (processorRef.current) processorRef.current.disconnect();\n    if (sourceRef.current) sourceRef.current.disconnect();\n    if (audioContextRef.current?.state !== 'closed') audioContextRef.current.close();\n    if (mediaStreamRef.current) mediaStreamRef.current.getTracks().forEach((t) => t.stop());\n    if (intervalRef.current) {\n      clearInterval(intervalRef.current);\n      intervalRef.current = null;\n    }\n\n    setRecording(false);\n\n    if (mode === 'full') {\n      const fullBlob = exportWAV(fullRecordingRef.current, audioContextRef.current.sampleRate);\n      sendChunk(fullBlob);\n    }\n  };\n\n  const sendChunk = async (blob) => {\n    const formData = new FormData();\n    formData.append('audio_file', blob, 'chunk.wav');\n    formData.append('voice_name', useVoiceStore.getState());\n    try {\n      const response = await fetch('http://127.0.0.1:8001/convert_voice_stream_bytes_webm', {\n        method: 'POST',\n        body: formData,\n      });\n      if (!response.ok) throw new Error('Failed to convert audio');\n      const arrayBuffer = await response.arrayBuffer();\n      handleNewChunk(arrayBuffer);\n    } catch (err) {\n      console.error('Error sending chunk:', err);\n    }\n  };\n\n  const exportWAV = (buffers, sampleRate) => {\n    const length = buffers.reduce((sum, b) => sum + b.length, 0);\n    const mergedBuffer = new Float32Array(length);\n    let offset = 0;\n    for (const b of buffers) {\n      mergedBuffer.set(b, offset);\n      offset += b.length;\n    }\n    const buffer = new ArrayBuffer(44 + mergedBuffer.length * 2);\n    const view = new DataView(buffer);\n    const writeString = (v, o, s) => [...s].forEach((ch, i) => v.setUint8(o + i, ch.charCodeAt(0)));\n    writeString(view, 0, 'RIFF');\n    view.setUint32(4, 36 + mergedBuffer.length * 2, true);\n    writeString(view, 8, 'WAVE');\n    writeString(view, 12, 'fmt ');\n    view.setUint32(16, 16, true);\n    view.setUint16(20, 1, true);\n    view.setUint16(22, 1, true);\n    view.setUint32(24, sampleRate, true);\n    view.setUint32(28, sampleRate * 2, true);\n    view.setUint16(32, 2, true);\n    view.setUint16(34, 16, true);\n    writeString(view, 36, 'data');\n    view.setUint32(40, mergedBuffer.length * 2, true);\n    for (let i = 0, idx = 44; i < mergedBuffer.length; i++, idx += 2) {\n      const s = Math.max(-1, Math.min(1, mergedBuffer[i]));\n      view.setInt16(idx, s < 0 ? s * 0x8000 : s * 0x7FFF, true);\n    }\n    return new Blob([view], { type: 'audio/wav' });\n  };\n\n  return (\n    <div className=\"p-4 max-w-xl mx-auto flex flex-col gap-4\">\n      <div className=\"flex gap-2\">\n        <select\n          className=\"border px-2 py-1\"\n          value={mode}\n          onChange={(e) => setMode(e.target.value)}\n          disabled={recording}\n        >\n          <option value=\"interval\">Interval</option>\n          <option value=\"silence\">Silence-Based</option>\n          <option value=\"hybrid\">Hybrid</option>\n          <option value=\"full\">Full Recording</option>\n        </select>\n        <button\n          className={`px-4 py-2 text-white rounded ${recording ? 'bg-red-600' : 'bg-green-600'}`}\n          onClick={recording ? stopRecording : startRecording}\n        >\n          {recording ? 'üõë Stop' : 'üéôÔ∏è Start'}\n        </button>\n      </div>\n      <audio ref={audioRef} controls autoPlay />\n    </div>\n  );\n}\n\nexport default AudioStreamer;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}